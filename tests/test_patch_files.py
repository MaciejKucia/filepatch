import re
import shutil
import sys
import unittest
import os
from os import listdir, getcwd
from os.path import join, exists, isdir, isfile, dirname, abspath
from tempfile import mkdtemp

verbose = False

TESTS = dirname(abspath(__file__))


class TestPatchFiles(unittest.TestCase):
    """
    unittest hack - test* methods are generated by add_test_methods() function
    below, using information about *.patch files from tests directory

    """

    def _assert_files_equal(self, file1, file2):
        f1 = f2 = None
        try:
            f1 = open(file1, "rb")
            f2 = open(file2, "rb")
            for line in f1:
                self.assertEqual(line, f2.readline())

        finally:
            if f2:
                f2.close()
            if f1:
                f1.close()

    def _assert_dirs_equal(self, dir1, dir2, ignore=None):
        """
        compare dir2 with reference dir1, ignoring entries
        from supplied list

        """
        # recursive
        if type(ignore) == str:
            ignore = [ignore]
        e2list = [en for en in listdir(dir2) if en not in ignore]
        for e1 in listdir(dir1):
            if e1 in ignore:
                continue
            e1path = join(dir1, e1)
            e2path = join(dir2, e1)
            self.assertTrue(exists(e1path))
            self.assertTrue(exists(e2path), "%s does not exist" % e2path)
            self.assertTrue(isdir(e1path) == isdir(e2path))
            if not isdir(e1path):
                self._assert_files_equal(e1path, e2path)
            else:
                self._assert_dirs_equal(e1path, e2path, ignore=ignore)
            e2list.remove(e1)
        for e2 in e2list:
            self.fail("extra file or directory: %s" % e2)

    def _run_test(self, testname):
        """
        boilerplate for running *.patch file tests
        """

        # 1. create temp test directory
        # 2. copy files
        # 3. execute file-based patch
        # 4. compare results
        # 5. cleanup on success

        tmpdir = mkdtemp(prefix="%s." % testname)

        basepath = join(TESTS, testname)
        basetmp = join(tmpdir, testname)

        patch_file = basetmp + ".patch"

        file_based = isfile(basepath + ".from")
        from_tgt = basetmp + ".from"

        if file_based:
            shutil.copy(basepath + ".from", tmpdir)
            shutil.copy(basepath + ".patch", tmpdir)
        else:
            # directory-based
            for e in listdir(basepath):
                epath = join(basepath, e)
                if not isdir(epath):
                    shutil.copy(epath, join(tmpdir, e))
                else:
                    shutil.copytree(epath, join(tmpdir, e))

        # 3.
        # test utility as a whole
        save_cwd = getcwd()
        os.chdir(tmpdir)
        if verbose:
            cmd = '%s -m filepatch "%s"' % (sys.executable, patch_file)
            print("\n" + cmd)
        else:
            cmd = '%s -m filepatch -q "%s"' % (sys.executable, patch_file)
        ret = os.system(cmd)
        assert ret == 0, "Error %d running test %s" % (ret, testname)
        os.chdir(save_cwd)

        # 4.
        # compare results
        if file_based:
            self._assert_files_equal(basepath + ".to", from_tgt)
        else:
            # recursive comparison
            self._assert_dirs_equal(join(basepath, "[result]"),
                                    tmpdir,
                                    ignore=["%s.patch" % testname, ".svn",
                                            "[result]"])

        shutil.rmtree(tmpdir)
        return 0


def add_test_methods(cls):
    """
    hack to generate test* methods in target class - one
    for each *.patch file in tests directory
    """

    # list testcases - every test starts with number
    # and add them as test* methods
    testptn = re.compile(r"^(?P<name>\d{2,}[^.]+).*$")

    testset = [testptn.match(e).group('name') for e in listdir(TESTS) if
               testptn.match(e)]
    testset = sorted(set(testset))

    for filename in testset:
        methname = 'test_' + filename

        def create_closure():
            name = filename
            return lambda self: self._run_test(name)

        test = create_closure()
        setattr(cls, methname, test)
        if verbose:
            print("added test method %s to %s" % (methname, cls))


add_test_methods(TestPatchFiles)
